# Patch 01: Integrate Quota Tracking with OpenAI API Calls
# This patch adds quota tracking to all OpenAI API calls in the system

--- a/backend/services/ai_provider_abstraction.py
+++ b/backend/services/ai_provider_abstraction.py
@@ -10,6 +10,7 @@
 import logging
 import os
 from typing import Any, Dict, Optional
+from services.openai_quota_tracker import quota_tracker
 
 # Placeholder for the real Agent SDK
 # from agents import Agent, Runner, AgentOutputSchema
@@ -71,7 +72,16 @@ class OpenAISDKProvider(BaseProvider):
                 sdk_agent = agent
             
             # Use Runner.run as static method (not context manager)
+            # Track API request start
+            workspace_id = kwargs.get('workspace_id')
+            task_id = kwargs.get('task_id')
+            goal_id = kwargs.get('goal_id')
+            
             result = await Runner.run(sdk_agent, prompt)
+            
+            # Track successful request
+            estimated_tokens = len(prompt.split()) * 1.3  # Rough token estimate
+            quota_tracker.record_request(success=True, tokens_used=int(estimated_tokens))
             
             # Process the result - handle multiple possible formats
             logger.info(f"üîç DEBUG: SDK result type: {type(result)}")
@@ -173,6 +183,8 @@ class OpenAISDKProvider(BaseProvider):
             return {"content": str(result)}
             
         except Exception as e:
+            # Track failed request
+            quota_tracker.record_openai_error(str(type(e).__name__), str(e))
             logger.error(f"‚ùå Error in real OpenAI SDK call: {e}", exc_info=True)
             raise

--- a/backend/tools/enhanced_document_search.py
+++ b/backend/tools/enhanced_document_search.py
@@ -5,6 +5,7 @@ import logging
 import json
 from typing import Dict, Any, List, Optional
 from datetime import datetime
+from services.openai_quota_tracker import quota_tracker
 
 logger = logging.getLogger(__name__)
 
@@ -297,6 +298,7 @@ class EnhancedDocumentSearch:
             try:
                 from openai import OpenAI
                 client = OpenAI()
+                prompt_text = f"Summarize: {' '.join([d.get('content', '') for d in docs[:3]])}"
                 
                 response = client.chat.completions.create(
                     model="gpt-4",
@@ -304,10 +306,14 @@ class EnhancedDocumentSearch:
                         {"role": "system", "content": "You are a helpful assistant."},
                         {"role": "user", "content": f"Summarize: {' '.join([d.get('content', '') for d in docs[:3]])}"}
                     ],
                     max_tokens=150
                 )
+                # Track successful OpenAI call
+                quota_tracker.record_request(success=True, tokens_used=150)
                 summary = response.choices[0].message.content
             except Exception as e:
+                # Track failed OpenAI call
+                quota_tracker.record_openai_error("openai_error", str(e))
                 logger.warning(f"Could not generate AI summary: {e}")
                 summary = "Multiple relevant documents found."

--- a/backend/ai_agents/conversational_simple.py
+++ b/backend/ai_agents/conversational_simple.py
@@ -12,6 +12,7 @@ from typing import Dict, Any, Optional, List, Tuple
 from datetime import datetime
 import json
 import re
+from services.openai_quota_tracker import quota_tracker
 
 # Import database functions
 from database import (
@@ -569,8 +570,12 @@ class ConversationalAgent:
             response = client.chat.completions.create(
                 model=model,
                 messages=messages
             )
+            # Track successful API call
+            estimated_tokens = len(str(messages)) // 4  # Rough token estimate
+            quota_tracker.record_request(success=True, tokens_used=estimated_tokens)
             return response.choices[0].message.content
         except Exception as e:
+            quota_tracker.record_openai_error("openai_error", str(e))
             logger.error(f"Error calling OpenAI: {e}")
             return f"I encountered an error: {str(e)}"