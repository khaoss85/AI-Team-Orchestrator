<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Service Registry Architecture – Dal Monolite all'Ecosistema | Memory System Scaling | AI Team Orchestrator</title>
    
    <!-- SEO Meta Tags -->
    <meta name="description" content="Capitolo 37 del libro AI Team Orchestrator: Service Registry Architecture – Dal Monolite all'Ecosistema">
    <meta name="keywords" content="AI agents, sistema AI-driven, architettura AI, OpenAI SDK, team AI">
    <meta name="author" content="Daniele Pelleri">
    <meta name="robots" content="index, follow">
    
    <!-- Open Graph -->
    <meta property="og:title" content="Service Registry Architecture – Dal Monolite all'Ecosistema">
    <meta property="og:description" content="Capitolo 37 del libro AI Team Orchestrator: Service Registry Architecture – Dal Monolite all'Ecosistema">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://books.danielepelleri.com/it/memory-system-scaling/service-registry-architecture-ecosistema/">
    
    <!-- Canonical -->
    <link rel="canonical" href="https://books.danielepelleri.com/it/memory-system-scaling/service-registry-architecture-ecosistema/">
    <link rel="alternate" hreflang="en" href="https://books.danielepelleri.com/en/memory-system-scaling/service-registry-architecture-ecosistema/">
    <link rel="alternate" hreflang="it" href="https://books.danielepelleri.com/it/memory-system-scaling/service-registry-architecture-ecosistema/">
    
    <style>
        /* Base Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: #2c3e50;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 2rem;
        }
        
        /* Breadcrumb Navigation */
        .breadcrumb {
            background: rgba(255, 255, 255, 0.9);
            padding: 1rem 2rem;
            border-radius: 10px;
            margin-bottom: 2rem;
            font-size: 0.9rem;
            backdrop-filter: blur(10px);
        }
        
        .breadcrumb a {
            color: #667eea;
            text-decoration: none;
        }
        
        .breadcrumb a:hover {
            text-decoration: underline;
        }
        
        .breadcrumb span {
            color: #7f8c8d;
            margin: 0 0.5rem;
        }
        
        /* Chapter Header */
        .chapter-header {
            background: white;
            padding: 3rem;
            border-radius: 20px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.1);
            margin-bottom: 3rem;
            text-align: center;
        }
        
        .chapter-instrument {
            font-size: 4rem;
            margin-bottom: 1rem;
        }
        
        .chapter-meta {
            display: flex;
            justify-content: center;
            gap: 2rem;
            margin-bottom: 1rem;
            font-size: 0.9rem;
            color: #7f8c8d;
            flex-wrap: wrap;
        }
        
        .chapter-title {
            font-size: 2.5rem;
            color: #2c3e50;
            margin-bottom: 1rem;
            font-weight: 700;
            line-height: 1.2;
        }
        
        /* Content Styles */
        .chapter-content {
            background: white;
            padding: 3rem;
            border-radius: 20px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.1);
            margin-bottom: 3rem;
        }
        
        .chapter-content h3 {
            font-size: 2rem;
            color: #2c3e50;
            margin: 2rem 0 1rem;
            border-bottom: 2px solid #667eea;
            padding-bottom: 0.5rem;
        }
        
        .chapter-content h4 {
            font-size: 1.5rem;
            color: #495057;
            margin: 1.5rem 0 1rem;
        }
        
        .chapter-content p {
            margin-bottom: 1.5rem;
            font-size: 1.1rem;
            line-height: 1.8;
        }
        
        .chapter-content ul, .chapter-content ol {
            margin: 1.5rem 0;
            padding-left: 2rem;
        }
        
        .chapter-content li {
            margin-bottom: 0.5rem;
            font-size: 1.1rem;
            line-height: 1.6;
        }
        
        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            margin: 2rem 0;
        }
        
        th, td {
            padding: 1rem;
            text-align: left;
            border-bottom: 1px solid #ecf0f1;
        }
        
        th {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            font-weight: 600;
        }
        
        /* Code Styles */
        pre {
            background: #2d3748;
            color: #e2e8f0;
            padding: 1.5rem;
            border-radius: 8px;
            overflow-x: auto;
            margin: 1.5rem 0;
            font-size: 0.9rem;
        }
        
        code {
            background: #f1f3f4;
            color: #d73a49;
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        }
        
        pre code {
            background: transparent;
            color: inherit;
            padding: 0;
        }
        
        /* Special Boxes */
        .war-story, .industry-insight, .architecture-section, .key-takeaways-section {
            border-radius: 10px;
            padding: 2rem;
            margin: 2rem 0;
        }
        
        .war-story {
            background: linear-gradient(135deg, #fff3cd, #ffeaa7);
            border-left: 4px solid #856404;
        }
        
        .industry-insight {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            border-left: 4px solid #28a745;
        }
        
        .architecture-section {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            border: 1px solid #dee2e6;
        }
        
        .key-takeaways-section {
            background: linear-gradient(135deg, #27ae60, #2ecc71);
            color: white;
        }
        
        /* Mermaid Container */
        .mermaid {
            background: #f8f9fa;
            padding: 2rem;
            border-radius: 10px;
            margin: 2rem 0;
            text-align: center;
        }
        
        /* Navigation */
        .chapter-nav-bottom {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 3rem 0;
            gap: 1rem;
            flex-wrap: wrap;
        }
        
        .nav-button {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 1rem 2rem;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            text-decoration: none;
            border-radius: 50px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
        }
        
        .nav-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 40px rgba(102, 126, 234, 0.6);
        }
        
        .nav-button.secondary {
            background: rgba(255, 255, 255, 0.9);
            color: #667eea;
            border: 2px solid #667eea;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }
        
        .nav-button.secondary:hover {
            background: white;
            box-shadow: 0 15px 40px rgba(0,0,0,0.15);
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }
            
            .chapter-header,
            .chapter-content {
                padding: 2rem;
            }
            
            .chapter-title {
                font-size: 2rem;
            }
            
            .chapter-nav-bottom {
                flex-direction: column;
                text-align: center;
            }
        }
        /* Reader Tools */
        .reader-tools {
            position: fixed;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 1rem;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
            transition: all 0.3s ease;
            min-width: 60px;
        }
        
        .reader-tools.collapsed {
            width: 60px;
            padding: 0.8rem;
        }
        
        .reader-tool {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.6rem;
            border: none;
            background: transparent;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.2s ease;
            color: #495057;
            font-size: 0.85rem;
            white-space: nowrap;
        }
        
        .reader-tool:hover {
            background: rgba(102, 126, 234, 0.1);
            color: #667eea;
        }
        
        .reader-tool.active {
            background: #667eea;
            color: white;
        }
        
        .reader-tool-icon {
            font-size: 1.1rem;
            flex-shrink: 0;
        }
        
        .reader-tool-label {
            font-size: 0.8rem;
            font-weight: 500;
        }
        
        .collapsed .reader-tool-label {
            display: none;
        }
        
        .reader-tools-toggle {
            position: absolute;
            top: -10px;
            left: -10px;
            width: 30px;
            height: 30px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }
        
        /* Language Switcher */
        .language-switcher {
            display: flex;
            background: rgba(0,0,0,0.1);
            border-radius: 6px;
            overflow: hidden;
        }
        
        .language-option {
            padding: 0.3rem 0.6rem;
            background: transparent;
            border: none;
            cursor: pointer;
            font-size: 0.7rem;
            font-weight: 600;
            color: #6c757d;
            transition: all 0.2s ease;
        }
        
        .language-option.active {
            background: #667eea;
            color: white;
        }
        
        /* Reading Progress */
        .reading-progress {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: rgba(102, 126, 234, 0.2);
            z-index: 1001;
        }
        
        .reading-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        /* Dark Mode */
        body.dark-mode {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e9ecef;
        }
        
        .dark-mode .container {
            color: #e9ecef;
        }
        
        .dark-mode .chapter-header,
        .dark-mode .chapter-content {
            background: rgba(255, 255, 255, 0.05);
            color: #e9ecef;
        }
        
        .dark-mode .breadcrumb {
            background: rgba(255, 255, 255, 0.1);
            color: #e9ecef;
        }
        
        .dark-mode .reader-tools {
            background: rgba(0, 0, 0, 0.8);
            color: #e9ecef;
        }
        
        .dark-mode .reader-tool {
            color: #e9ecef;
        }
        
        .dark-mode .reader-tool:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .reader-tools {
                right: 10px;
                padding: 0.8rem;
                min-width: 50px;
            }
            
            .reader-tools.collapsed {
                width: 50px;
                padding: 0.6rem;
            }
            
            .reader-tool {
                padding: 0.5rem;
            }
            
            .reader-tool-label {
                font-size: 0.75rem;
            }
        }

        /* Fixed Bookmark Toast */
        .bookmark-toast {
            position: fixed;
            top: 80px;
            right: 20px;
            background: #28a745;
            color: white;
            padding: 0.8rem 1.2rem;
            border-radius: 8px;
            z-index: 1002;
            transform: translateX(350px);
            opacity: 0;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            box-shadow: 0 5px 15px rgba(40, 167, 69, 0.3);
            pointer-events: none;
        }
        
        .bookmark-toast.show {
            transform: translateX(0);
            opacity: 1;
            pointer-events: auto;
        }
        
        .bookmark-toast.error {
            background: #dc3545;
            box-shadow: 0 5px 15px rgba(220, 53, 69, 0.3);
        }


            /* Reader Tools */
        .reader-tools {
            position: fixed;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 1rem;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
            transition: all 0.3s ease;
            min-width: 60px;
        }
        .reader-tools.collapsed { width: 60px; padding: 0.8rem; }
        .reader-tool { display: flex; align-items: center; gap: 0.5rem; padding: 0.6rem; border: none; background: transparent; cursor: pointer; border-radius: 8px; transition: all 0.2s ease; color: #495057; font-size: 0.85rem; white-space: nowrap; }
        .reader-tool:hover { background: rgba(102, 126, 234, 0.1); color: #667eea; }
        .reader-tool.active { background: #667eea; color: white; }
        .reader-tool-icon { font-size: 1.1rem; flex-shrink: 0; }
        .reader-tool-label { font-size: 0.8rem; font-weight: 500; }
        .collapsed .reader-tool-label { display: none; }
        .reader-tools-toggle { position: absolute; top: -10px; left: -10px; width: 30px; height: 30px; background: #667eea; color: white; border: none; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 0.8rem; box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3); }
        .reading-progress { position: fixed; top: 0; left: 0; width: 100%; height: 3px; background: rgba(102, 126, 234, 0.2); z-index: 1001; }
        .reading-progress-fill { height: 100%; background: linear-gradient(90deg, #667eea, #764ba2); width: 0%; transition: width 0.3s ease; }
        body.dark-mode { background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); color: #e9ecef; }
        .dark-mode .container { color: #e9ecef; }
        .dark-mode .chapter-header, .dark-mode .chapter-content { background: rgba(255, 255, 255, 0.05); color: #e9ecef; }
        .dark-mode .breadcrumb { background: rgba(255, 255, 255, 0.1); color: #e9ecef; }
        .dark-mode .reader-tools { background: rgba(0, 0, 0, 0.8); color: #e9ecef; }
        .dark-mode .reader-tool { color: #e9ecef; }
        .dark-mode .reader-tool:hover { background: rgba(255, 255, 255, 0.1); }
        @media (max-width: 768px) { .reader-tools { right: 10px; padding: 0.8rem; min-width: 50px; } .reader-tools.collapsed { width: 50px; padding: 0.6rem; } .reader-tool { padding: 0.5rem; } .reader-tool-label { font-size: 0.75rem; } }
        .bookmark-toast { position: fixed; top: 80px; right: 20px; background: #28a745; color: white; padding: 0.8rem 1.2rem; border-radius: 8px; z-index: 1002; transform: translateX(300px); transition: transform 0.3s ease; font-size: 0.9rem; box-shadow: 0 5px 15px rgba(40, 167, 69, 0.3); }
        .bookmark-toast.show { transform: translateX(0); }
        .bookmark-toast.error { background: #dc3545; box-shadow: 0 5px 15px rgba(220, 53, 69, 0.3); }
        .bookmarks-modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); z-index: 2000; backdrop-filter: blur(5px); }
        .bookmarks-modal.show { display: flex; align-items: center; justify-content: center; animation: fadeIn 0.3s ease; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .bookmarks-content { background: white; border-radius: 20px; padding: 2rem; max-width: 600px; width: 90%; max-height: 80vh; overflow-y: auto; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3); animation: slideUp 0.3s ease; }
        @keyframes slideUp { from { transform: translateY(50px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        .dark-mode .bookmarks-content { background: #1a1a2e; color: #e9ecef; }
        .bookmarks-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem; padding-bottom: 1rem; border-bottom: 2px solid #667eea; }
        .bookmarks-title { font-size: 1.5rem; font-weight: 700; color: #2c3e50; display: flex; align-items: center; gap: 0.5rem; }
        .dark-mode .bookmarks-title { color: #e9ecef; }
        .close-bookmarks { background: none; border: none; font-size: 1.5rem; cursor: pointer; color: #7f8c8d; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; border-radius: 50%; transition: all 0.2s ease; }
        .close-bookmarks:hover { background: rgba(102, 126, 234, 0.1); color: #667eea; }
        .bookmarks-list { max-height: 400px; overflow-y: auto; }
        .bookmark-item { display: flex; justify-content: space-between; align-items: center; padding: 1rem; border-radius: 10px; margin-bottom: 0.5rem; background: rgba(102, 126, 234, 0.05); transition: all 0.2s ease; }
        .bookmark-item:hover { background: rgba(102, 126, 234, 0.1); transform: translateX(5px); }
        .dark-mode .bookmark-item { background: rgba(255, 255, 255, 0.05); }
        .dark-mode .bookmark-item:hover { background: rgba(255, 255, 255, 0.1); }
        .bookmark-info { flex-grow: 1; }
        .bookmark-title { font-weight: 600; color: #2c3e50; text-decoration: none; font-size: 1rem; line-height: 1.4; }
        .dark-mode .bookmark-title { color: #e9ecef; }
        .bookmark-title:hover { color: #667eea; }
        .bookmark-date { font-size: 0.8rem; color: #7f8c8d; margin-top: 0.3rem; }
        .bookmark-actions { display: flex; gap: 0.5rem; }
        .bookmark-action { background: none; border: none; cursor: pointer; padding: 0.3rem; border-radius: 5px; transition: all 0.2s ease; color: #7f8c8d; }
        .bookmark-action:hover { background: rgba(220, 53, 69, 0.1); color: #dc3545; }
        .empty-bookmarks { text-align: center; padding: 2rem; color: #7f8c8d; }
        .empty-bookmarks-icon { font-size: 3rem; margin-bottom: 1rem; opacity: 0.5; }
        .language-select { background: transparent; border: none; color: inherit; font-size: 0.75rem; font-weight: 600; cursor: pointer; outline: none; min-width: 60px; }
        .language-select option { background: white; color: #2c3e50; }
        .dark-mode .language-select option { background: #1a1a2e; color: #e9ecef; }

    </style>

    <style>
    .contextual-link {
        color: #667eea;
        text-decoration: none;
        font-weight: 500;
        border-bottom: 1px dotted #667eea;
        transition: all 0.2s ease;
    }
    
    .contextual-link:hover {
        color: #5a6fd8;
        border-bottom-style: solid;
    }
    
    .dark-mode .contextual-link {
        color: #9bb5ff;
        border-bottom-color: #9bb5ff;
    }
    </style>
        <link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,CiAgICA8c3ZnIHdpZHRoPSIzMiIgaGVpZ2h0PSIzMiIgdmlld0JveD0iMCAwIDMyIDMyIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgogICAgICAgIDxkZWZzPgogICAgICAgICAgICA8bGluZWFyR3JhZGllbnQgaWQ9ImdyYWQxIiB4MT0iMCUiIHkxPSIwJSIgeDI9IjEwMCUiIHkyPSIxMDAlIj4KICAgICAgICAgICAgICAgIDxzdG9wIG9mZnNldD0iMCUiIHN0eWxlPSJzdG9wLWNvbG9yOiM2NjdlZWE7c3RvcC1vcGFjaXR5OjEiIC8+CiAgICAgICAgICAgICAgICA8c3RvcCBvZmZzZXQ9IjEwMCUiIHN0eWxlPSJzdG9wLWNvbG9yOiM3NjRiYTI7c3RvcC1vcGFjaXR5OjEiIC8+CiAgICAgICAgICAgIDwvbGluZWFyR3JhZGllbnQ+CiAgICAgICAgPC9kZWZzPgogICAgICAgIDwhLS0gQmFja2dyb3VuZCBjaXJjbGUgLS0+CiAgICAgICAgPGNpcmNsZSBjeD0iMTYiIGN5PSIxNiIgcj0iMTUiIGZpbGw9InVybCgjZ3JhZDEpIiBzdHJva2U9IiNmZmYiIHN0cm9rZS13aWR0aD0iMiIvPgogICAgICAgIDwhLS0gQUkgQnJhaW4gaWNvbiAtLT4KICAgICAgICA8Y2lyY2xlIGN4PSIxNiIgY3k9IjEzIiByPSI4IiBmaWxsPSJub25lIiBzdHJva2U9IiNmZmYiIHN0cm9rZS13aWR0aD0iMiIvPgogICAgICAgIDxjaXJjbGUgY3g9IjEzIiBjeT0iMTEiIHI9IjEiIGZpbGw9IiNmZmYiLz4KICAgICAgICA8Y2lyY2xlIGN4PSIxOSIgY3k9IjExIiByPSIxIiBmaWxsPSIjZmZmIi8+CiAgICAgICAgPHBhdGggZD0iTTEyIDE1YzEgMiAzIDIgNCAyczMgMCA0LTIiIHN0cm9rZT0iI2ZmZiIgc3Ryb2tlLXdpZHRoPSIxLjUiIGZpbGw9Im5vbmUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPgogICAgICAgIDwhLS0gVGVhbSBvcmNoZXN0cmF0aW9uIGxpbmVzIC0tPgogICAgICAgIDxwYXRoIGQ9Ik04IDI0TDE2IDIwTDI0IDI0IiBzdHJva2U9IiNmZmYiIHN0cm9rZS13aWR0aD0iMiIgZmlsbD0ibm9uZSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+CiAgICAgICAgPGNpcmNsZSBjeD0iOCIgY3k9IjI0IiByPSIyIiBmaWxsPSIjZmZmIi8+CiAgICAgICAgPGNpcmNsZSBjeD0iMTYiIGN5PSIyMCIgcj0iMiIgZmlsbD0iI2ZmZiIvPgogICAgICAgIDxjaXJjbGUgY3g9IjI0IiBjeT0iMjQiIHI9IjIiIGZpbGw9IiNmZmYiLz4KICAgIDwvc3ZnPgogICAg">
    <link rel="apple-touch-icon" href="data:image/svg+xml;base64,CiAgICA8c3ZnIHdpZHRoPSIzMiIgaGVpZ2h0PSIzMiIgdmlld0JveD0iMCAwIDMyIDMyIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgogICAgICAgIDxkZWZzPgogICAgICAgICAgICA8bGluZWFyR3JhZGllbnQgaWQ9ImdyYWQxIiB4MT0iMCUiIHkxPSIwJSIgeDI9IjEwMCUiIHkyPSIxMDAlIj4KICAgICAgICAgICAgICAgIDxzdG9wIG9mZnNldD0iMCUiIHN0eWxlPSJzdG9wLWNvbG9yOiM2NjdlZWE7c3RvcC1vcGFjaXR5OjEiIC8+CiAgICAgICAgICAgICAgICA8c3RvcCBvZmZzZXQ9IjEwMCUiIHN0eWxlPSJzdG9wLWNvbG9yOiM3NjRiYTI7c3RvcC1vcGFjaXR5OjEiIC8+CiAgICAgICAgICAgIDwvbGluZWFyR3JhZGllbnQ+CiAgICAgICAgPC9kZWZzPgogICAgICAgIDwhLS0gQmFja2dyb3VuZCBjaXJjbGUgLS0+CiAgICAgICAgPGNpcmNsZSBjeD0iMTYiIGN5PSIxNiIgcj0iMTUiIGZpbGw9InVybCgjZ3JhZDEpIiBzdHJva2U9IiNmZmYiIHN0cm9rZS13aWR0aD0iMiIvPgogICAgICAgIDwhLS0gQUkgQnJhaW4gaWNvbiAtLT4KICAgICAgICA8Y2lyY2xlIGN4PSIxNiIgY3k9IjEzIiByPSI4IiBmaWxsPSJub25lIiBzdHJva2U9IiNmZmYiIHN0cm9rZS13aWR0aD0iMiIvPgogICAgICAgIDxjaXJjbGUgY3g9IjEzIiBjeT0iMTEiIHI9IjEiIGZpbGw9IiNmZmYiLz4KICAgICAgICA8Y2lyY2xlIGN4PSIxOSIgY3k9IjExIiByPSIxIiBmaWxsPSIjZmZmIi8+CiAgICAgICAgPHBhdGggZD0iTTEyIDE1YzEgMiAzIDIgNCAyczMgMCA0LTIiIHN0cm9rZT0iI2ZmZiIgc3Ryb2tlLXdpZHRoPSIxLjUiIGZpbGw9Im5vbmUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPgogICAgICAgIDwhLS0gVGVhbSBvcmNoZXN0cmF0aW9uIGxpbmVzIC0tPgogICAgICAgIDxwYXRoIGQ9Ik04IDI0TDE2IDIwTDI0IDI0IiBzdHJva2U9IiNmZmYiIHN0cm9rZS13aWR0aD0iMiIgZmlsbD0ibm9uZSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+CiAgICAgICAgPGNpcmNsZSBjeD0iOCIgY3k9IjI0IiByPSIyIiBmaWxsPSIjZmZmIi8+CiAgICAgICAgPGNpcmNsZSBjeD0iMTYiIGN5PSIyMCIgcj0iMiIgZmlsbD0iI2ZmZiIvPgogICAgICAgIDxjaXJjbGUgY3g9IjI0IiBjeT0iMjQiIHI9IjIiIGZpbGw9IiNmZmYiLz4KICAgIDwvc3ZnPgogICAg">
</head>
<body>
    <div class="container">
        <!-- Breadcrumb -->
        <nav class="breadcrumb">
            <a href="../../ai-team-orchestrator.html">🏠 AI Team Orchestrator</a>
            <span>›</span>
            <a href="../">🎭 Memory System Scaling</a>
            <span>›</span>
            <span>Service Registry Architecture – Dal Monolite all'Ecosistema</span>
        </nav>

        <!-- Chapter Header -->
        <header class="chapter-header">
            <div class="chapter-instrument">🎭</div>
            <div class="chapter-meta">
                <span>🎭 Movimento 4 di 4</span>
                <span>📖 Capitolo 37 di 42</span>
                <span>⏱️ ~12 min lettura</span>
                <span>📊 Livello: Expert</span>
            </div>
            <h1 class="chapter-title">Service Registry Architecture – Dal Monolite all'Ecosistema</h1>
        </header>

        <!-- Main Content -->
        <article class="chapter-content">
<p>Avevamo un sistema resiliente e performante, ma stavamo raggiungendo i limiti architetturali del design monolitico. Con 15+ componenti principali, 200+ funzioni, e un team di sviluppo che cresceva da 3 a 8 persone, ogni cambiamento richiedeva coordinazione sempre più complessa. Era il momento di fare il grande salto: <strong>da monolite a service-oriented architecture</strong>.</p>

<p>Ma non potevamo semplicemente "spezzare" il monolite senza una strategia. Avevamo bisogno di un <strong>Service Registry</strong> – un sistema che permettesse ai servizi di trovarsi, comunicare e coordinarsi senza accoppiamento stretto.</p>

<h3>Il Catalizzatore: "The Integration Hell Week"</h3>

<p>La decisione di implementare una service registry è nata da una settimana particolarmente frustrante che abbiamo soprannominato "Integration Hell Week".</p>

<p>In quella settimana, stavamo tentando di integrare tre nuove funzionalità contemporaneamente:
- Un nuovo tipo di agente (Data Analyst)
- Un nuovo tool (Advanced Web Scraper)  
- Un nuovo provider AI (Anthropic Claude)</p>

<p><em>Logbook dell'Inferno Integrativo:</em></p>

<pre><code class="language-text">Day 1: Data Analyst integration breaks existing ContentSpecialist workflow
Day 2: Web Scraper tool conflicts with existing search tool configuration
Day 3: Claude provider requires different prompt format, breaks all existing prompts
Day 4: Fixing Claude breaks OpenAI integration 
Day 5: Emergency meeting: &quot;We can&#x27;t keep developing like this&quot;</code></pre>

<p><strong>Il Problema Fondamentale:</strong> Ogni nuovo componente doveva "conoscere" tutti gli altri componenti esistenti. Ogni integrazione richiedeva modifiche a 5-10 file diversi. Non era più sostenibile.</p>

<h3>L'Architettura del Service Registry: Scoperta Intelligente</h3>

<p>La soluzione era creare un <strong>service registry</strong> che permettesse ai componenti di registrarsi dinamicamente e scoprirsi a vicenda senza hard-coding dependencies.</p>

<p><em>Codice di riferimento: <code>backend/services/service_registry.py</code></em></p>

<pre><code class="language-python">class ServiceRegistry:
    &quot;&quot;&quot;
    Central registry per service discovery e capability management
    in un&#x27;architettura distribuita
    &quot;&quot;&quot;
    
    def __init__(self):
        self.services = {}  # service_name -&gt; ServiceDefinition
        self.capabilities = {}  # capability -&gt; List[service_name]
        self.health_monitors = {}  # service_name -&gt; HealthMonitor
        self.load_balancers = {}  # service_name -&gt; LoadBalancer
        
    async def register_service(
        self,
        service_definition: ServiceDefinition
    ) -&gt; ServiceRegistration:
        &quot;&quot;&quot;
        Register a new service with its capabilities and endpoints
        &quot;&quot;&quot;
        service_name = service_definition.name
        
        # Validate service definition
        await self._validate_service_definition(service_definition)
        
        # Store service definition
        self.services[service_name] = service_definition
        
        # Index capabilities for discovery
        for capability in service_definition.capabilities:
            if capability not in self.capabilities:
                self.capabilities[capability] = []
            self.capabilities[capability].append(service_name)
        
        # Setup health monitoring
        health_monitor = HealthMonitor(service_definition)
        self.health_monitors[service_name] = health_monitor
        await health_monitor.start_monitoring()
        
        # Setup load balancing if multiple instances
        if service_definition.instance_count &gt; 1:
            load_balancer = LoadBalancer(service_definition)
            self.load_balancers[service_name] = load_balancer
        
        logger.info(f&quot;Service {service_name} registered with capabilities: {service_definition.capabilities}&quot;)
        
        return ServiceRegistration(
            service_name=service_name,
            registration_id=str(uuid4()),
            health_check_url=health_monitor.health_check_url,
            capabilities_registered=service_definition.capabilities
        )
    
    async def discover_services_by_capability(
        self,
        required_capability: str,
        selection_criteria: ServiceSelectionCriteria = None
    ) -&gt; List[ServiceEndpoint]:
        &quot;&quot;&quot;
        Find all services that provide a specific capability
        &quot;&quot;&quot;
        candidate_services = self.capabilities.get(required_capability, [])
        
        if not candidate_services:
            raise NoServiceFoundException(f&quot;No services found for capability: {required_capability}&quot;)
        
        # Filter by health status
        healthy_services = []
        for service_name in candidate_services:
            health_monitor = self.health_monitors.get(service_name)
            if health_monitor and await health_monitor.is_healthy():
                healthy_services.append(service_name)
        
        if not healthy_services:
            raise NoHealthyServiceException(f&quot;No healthy services for capability: {required_capability}&quot;)
        
        # Apply selection criteria
        if selection_criteria:
            selected_services = await self._apply_selection_criteria(
                healthy_services, selection_criteria
            )
        else:
            selected_services = healthy_services
        
        # Convert to service endpoints
        service_endpoints = []
        for service_name in selected_services:
            service_def = self.services[service_name]
            
            # Use load balancer if available
            if service_name in self.load_balancers:
                endpoint = await self.load_balancers[service_name].get_endpoint()
            else:
                endpoint = service_def.primary_endpoint
            
            service_endpoints.append(ServiceEndpoint(
                service_name=service_name,
                endpoint_url=endpoint,
                capabilities=service_def.capabilities,
                current_load=await self._get_current_load(service_name)
            ))
        
        return service_endpoints</code></pre>

<h3>Service Definition: Il Contratto dei Servizi</h3>

<p>Per far funzionare il service discovery, ogni servizio doveva dichiararsi usando una <strong>service definition</strong> strutturata:</p>

<pre><code class="language-python">@dataclass
class ServiceDefinition:
    &quot;&quot;&quot;
    Complete definition of a service and its capabilities
    &quot;&quot;&quot;
    name: str
    version: str
    description: str
    
    # Service endpoints
    primary_endpoint: str
    health_check_endpoint: str
    metrics_endpoint: Optional[str] = None
    
    # Capabilities this service provides
    capabilities: List[str] = field(default_factory=list)
    
    # Dependencies this service requires
    required_capabilities: List[str] = field(default_factory=list)
    
    # Performance characteristics
    expected_response_time_ms: int = 1000
    max_concurrent_requests: int = 100
    instance_count: int = 1
    
    # Resource requirements
    memory_requirement_mb: int = 512
    cpu_requirement_cores: float = 0.5
    
    # Service metadata
    tags: List[str] = field(default_factory=list)
    contact_team: str = &quot;platform&quot;
    documentation_url: Optional[str] = None

# Example service definitions
DATA_ANALYST_AGENT_SERVICE = ServiceDefinition(
    name=&quot;data_analyst_agent&quot;,
    version=&quot;1.2.0&quot;,
    description=&quot;Specialized agent for data analysis and statistical insights&quot;,
    
    primary_endpoint=&quot;http://localhost:8001/api/v1/data-analyst&quot;,
    health_check_endpoint=&quot;http://localhost:8001/health&quot;,
    metrics_endpoint=&quot;http://localhost:8001/metrics&quot;,
    
    capabilities=[
        &quot;data_analysis&quot;,
        &quot;statistical_modeling&quot;, 
        &quot;chart_generation&quot;,
        &quot;trend_analysis&quot;,
        &quot;report_generation&quot;
    ],
    
    required_capabilities=[
        &quot;ai_pipeline_access&quot;,
        &quot;database_read_access&quot;,
        &quot;file_storage_access&quot;
    ],
    
    expected_response_time_ms=3000,  # Data analysis can be slow
    max_concurrent_requests=25,      # CPU intensive
    
    tags=[&quot;agent&quot;, &quot;analytics&quot;, &quot;data&quot;],
    contact_team=&quot;ai_agents_team&quot;
)

WEB_SCRAPER_TOOL_SERVICE = ServiceDefinition(
    name=&quot;advanced_web_scraper&quot;,
    version=&quot;2.1.0&quot;, 
    description=&quot;Advanced web scraping with JavaScript rendering and anti-bot evasion&quot;,
    
    primary_endpoint=&quot;http://localhost:8002/api/v1/scraper&quot;,
    health_check_endpoint=&quot;http://localhost:8002/health&quot;,
    
    capabilities=[
        &quot;web_scraping&quot;,
        &quot;javascript_rendering&quot;,
        &quot;pdf_extraction&quot;, 
        &quot;structured_data_extraction&quot;,
        &quot;batch_scraping&quot;
    ],
    
    required_capabilities=[
        &quot;proxy_service&quot;,
        &quot;cache_service&quot;  
    ],
    
    expected_response_time_ms=5000,  # Network dependent
    max_concurrent_requests=50,
    instance_count=3,  # Scale for throughput
    
    tags=[&quot;tool&quot;, &quot;web&quot;, &quot;extraction&quot;],
    contact_team=&quot;tools_team&quot;
)</code></pre>

<h3>"War Story": The Service Discovery Race Condition</h3>

<p>Durante l'implementazione del service registry, abbiamo scoperto un problema insidioso che ha quasi fatto fallire l'intero progetto.</p>

<pre><code class="language-text">ERROR: ServiceNotAvailableException in workspace_executor.py:142
ERROR: Required capability &#x27;content_generation&#x27; not found
DEBUG: Available services: [&#x27;data_analyst_agent&#x27;, &#x27;web_scraper_tool&#x27;]
DEBUG: content_specialist_agent status: STARTING...</code></pre>

<p>Il problema? <strong>Service startup race conditions</strong>. Quando il sistema si avviava, alcuni servizi si registravano prima di altri, e i servizi che si avviavano per primi tentavano di usare servizi che non erano ancora pronti.</p>

<p><strong>Root Cause Analysis:</strong>
1. ContentSpecialist service richiede 15 secondi per startup (carica modelli ML)
2. Executor service si avvia in 3 secondi e cerca subito ContentSpecialist
3. ContentSpecialist non è ancora registrato → Task fallisce</p>

<h3>La Soluzione: Dependency-Aware Startup Orchestration</h3>

<pre><code class="language-python">class ServiceStartupOrchestrator:
    &quot;&quot;&quot;
    Orchestrates service startup based on dependency graph
    &quot;&quot;&quot;
    
    def __init__(self, service_registry: ServiceRegistry):
        self.service_registry = service_registry
        self.startup_graph = DependencyGraph()
        
    async def orchestrate_startup(
        self,
        service_definitions: List[ServiceDefinition]
    ) -&gt; StartupResult:
        &quot;&quot;&quot;
        Start services in dependency order, waiting for readiness
        &quot;&quot;&quot;
        # 1. Build dependency graph
        self.startup_graph.build_from_definitions(service_definitions)
        
        # 2. Calculate startup order (topological sort)
        startup_order = self.startup_graph.get_startup_order()
        
        logger.info(f&quot;Calculated startup order: {[s.name for s in startup_order]}&quot;)
        
        # 3. Start services in batches (services with no deps start together)
        startup_batches = self.startup_graph.get_startup_batches()
        
        started_services = []
        for batch_index, service_batch in enumerate(startup_batches):
            logger.info(f&quot;Starting batch {batch_index}: {[s.name for s in service_batch]}&quot;)
            
            # Start all services in this batch concurrently
            batch_tasks = []
            for service_def in service_batch:
                task = asyncio.create_task(
                    self._start_service_with_health_wait(service_def)
                )
                batch_tasks.append(task)
            
            # Wait for all services in batch to be ready
            batch_results = await asyncio.gather(*batch_tasks, return_exceptions=True)
            
            # Check for failures
            for i, result in enumerate(batch_results):
                if isinstance(result, Exception):
                    service_name = service_batch[i].name
                    logger.error(f&quot;Failed to start service {service_name}: {result}&quot;)
                    
                    # Rollback all started services
                    await self._rollback_startup(started_services)
                    raise ServiceStartupException(f&quot;Service {service_name} failed to start&quot;)
                else:
                    started_services.append(result)
        
        return StartupResult(
            services_started=len(started_services),
            total_startup_time=time.time() - startup_start_time,
            service_order=[s.service_name for s in started_services]
        )
    
    async def _start_service_with_health_wait(
        self,
        service_def: ServiceDefinition,
        max_wait_seconds: int = 60
    ) -&gt; ServiceStartupResult:
        &quot;&quot;&quot;
        Start service and wait until it&#x27;s healthy and ready
        &quot;&quot;&quot;
        logger.info(f&quot;Starting service: {service_def.name}&quot;)
        
        # 1. Start the service process
        service_process = await self._start_service_process(service_def)
        
        # 2. Wait for health check to pass
        health_check_url = service_def.health_check_endpoint
        start_time = time.time()
        
        while time.time() - start_time &lt; max_wait_seconds:
            try:
                async with aiohttp.ClientSession() as session:
                    async with session.get(health_check_url, timeout=5) as response:
                        if response.status == 200:
                            health_data = await response.json()
                            if health_data.get(&quot;status&quot;) == &quot;healthy&quot;:
                                # Service is healthy, register it
                                registration = await self.service_registry.register_service(service_def)
                                
                                logger.info(f&quot;Service {service_def.name} started and registered successfully&quot;)
                                return ServiceStartupResult(
                                    service_name=service_def.name,
                                    registration=registration,
                                    startup_time=time.time() - start_time
                                )
            except Exception as e:
                logger.debug(f&quot;Health check failed for {service_def.name}: {e}&quot;)
            
            # Wait before next health check
            await asyncio.sleep(2)
        
        # Timeout - service failed to become healthy
        await self._stop_service_process(service_process)
        raise ServiceStartupTimeoutException(
            f&quot;Service {service_def.name} failed to become healthy within {max_wait_seconds}s&quot;
        )</code></pre>

<h3>Smart Service Selection: Più di Load Balancing</h3>

<p>Con multiple services che forniscono le stesse capabilities, avevamo bisogno di <strong>intelligenza nella selezione dei servizi</strong>:</p>

<pre><code class="language-python">class IntelligentServiceSelector:
    &quot;&quot;&quot;
    AI-driven service selection basato su performance, load, e context
    &quot;&quot;&quot;
    
    async def select_optimal_service(
        self,
        required_capability: str,
        request_context: RequestContext,
        performance_requirements: PerformanceRequirements
    ) -&gt; ServiceEndpoint:
        &quot;&quot;&quot;
        Select best service based on current conditions and requirements
        &quot;&quot;&quot;
        # Get all candidate services
        candidates = await self.service_registry.discover_services_by_capability(
            required_capability
        )
        
        if not candidates:
            raise NoServiceAvailableException(f&quot;No services for capability: {required_capability}&quot;)
        
        # Score each candidate service
        service_scores = []
        for service in candidates:
            score = await self._calculate_service_score(
                service, request_context, performance_requirements
            )
            service_scores.append((service, score))
        
        # Sort by score (highest first)
        service_scores.sort(key=lambda x: x[1], reverse=True)
        
        # Select best service with some randomization to avoid thundering herd
        if len(service_scores) &gt; 1 and service_scores[0][1] - service_scores[1][1] &lt; 0.1:
            # Top services are very close - add randomization
            top_services = [s for s, score in service_scores if score &gt;= service_scores[0][1] - 0.1]
            selected_service = random.choice(top_services)
        else:
            selected_service = service_scores[0][0]
        
        logger.info(f&quot;Selected service {selected_service.service_name} for {required_capability}&quot;)
        return selected_service
    
    async def _calculate_service_score(
        self,
        service: ServiceEndpoint,
        context: RequestContext,  
        requirements: PerformanceRequirements
    ) -&gt; float:
        &quot;&quot;&quot;
        Calculate suitability score for service based on multiple factors
        &quot;&quot;&quot;
        score_factors = {}
        
        # Factor 1: Current load (0.0 = overloaded, 1.0 = no load)
        load_factor = 1.0 - min(service.current_load, 1.0)
        score_factors[&quot;load&quot;] = load_factor * 0.3
        
        # Factor 2: Historical performance for this context
        historical_performance = await self._get_historical_performance(
            service.service_name, context
        )
        score_factors[&quot;performance&quot;] = historical_performance * 0.25
        
        # Factor 3: Geographic/network proximity
        network_proximity = await self._calculate_network_proximity(service)
        score_factors[&quot;proximity&quot;] = network_proximity * 0.15
        
        # Factor 4: Specialization match (how well suited for this specific request)
        specialization_match = await self._calculate_specialization_match(
            service, context, requirements
        )
        score_factors[&quot;specialization&quot;] = specialization_match * 0.2
        
        # Factor 5: Cost efficiency
        cost_efficiency = await self._calculate_cost_efficiency(service, requirements)
        score_factors[&quot;cost&quot;] = cost_efficiency * 0.1
        
        # Combine all factors
        total_score = sum(score_factors.values())
        
        logger.debug(f&quot;Service {service.service_name} score: {total_score:.3f} {score_factors}&quot;)
        return total_score</code></pre>

<h3>Service Health Monitoring: Proactive vs Reactive</h3>

<p>Un service registry è inutile se i servizi registrati sono down. Abbiamo implementato <strong>proactive health monitoring</strong>:</p>

<pre><code class="language-python">class ServiceHealthMonitor:
    &quot;&quot;&quot;
    Continuous health monitoring con predictive failure detection
    &quot;&quot;&quot;
    
    def __init__(self, service_registry: ServiceRegistry):
        self.service_registry = service_registry
        self.health_history = ServiceHealthHistory()
        self.failure_predictor = ServiceFailurePredictor()
        
    async def start_monitoring(self):
        &quot;&quot;&quot;
        Start continuous health monitoring for all registered services
        &quot;&quot;&quot;
        while True:
            # Get all registered services
            services = await self.service_registry.get_all_services()
            
            # Monitor each service concurrently
            monitoring_tasks = []
            for service in services:
                task = asyncio.create_task(self._monitor_service_health(service))
                monitoring_tasks.append(task)
            
            # Wait for all health checks (with timeout)
            await asyncio.wait(monitoring_tasks, timeout=30)
            
            # Analyze health trends and predict failures
            await self._analyze_health_trends()
            
            # Wait before next monitoring cycle
            await asyncio.sleep(30)  # Monitor every 30 seconds
    
    async def _monitor_service_health(self, service: ServiceDefinition):
        &quot;&quot;&quot;
        Comprehensive health check for a single service
        &quot;&quot;&quot;
        service_name = service.name
        health_metrics = {}
        
        try:
            # 1. Basic connectivity check
            connectivity_ok = await self._check_connectivity(service.health_check_endpoint)
            health_metrics[&quot;connectivity&quot;] = connectivity_ok
            
            # 2. Response time check
            response_time = await self._measure_response_time(service.primary_endpoint)
            health_metrics[&quot;response_time_ms&quot;] = response_time
            health_metrics[&quot;response_time_ok&quot;] = response_time &lt; service.expected_response_time_ms * 1.5
            
            # 3. Resource utilization check (if metrics endpoint available)
            if service.metrics_endpoint:
                resource_metrics = await self._get_resource_metrics(service.metrics_endpoint)
                health_metrics.update(resource_metrics)
            
            # 4. Capability-specific health checks
            for capability in service.capabilities:
                capability_health = await self._test_capability_health(service, capability)
                health_metrics[f&quot;capability_{capability}&quot;] = capability_health
            
            # 5. Calculate overall health score
            overall_health = self._calculate_overall_health_score(health_metrics)
            health_metrics[&quot;overall_health_score&quot;] = overall_health
            
            # 6. Update service registry health status
            await self.service_registry.update_service_health(service_name, health_metrics)
            
            # 7. Store health history for trend analysis
            await self.health_history.record_health_check(service_name, health_metrics)
            
            # 8. Check for degradation patterns
            if overall_health &lt; 0.8:
                await self._handle_service_degradation(service, health_metrics)
            
        except Exception as e:
            logger.error(f&quot;Health monitoring failed for {service_name}: {e}&quot;)
            await self.service_registry.mark_service_unhealthy(
                service_name, 
                reason=str(e),
                timestamp=datetime.utcnow()
            )</code></pre>

<h3>The Service Mesh Evolution: From Registry to Orchestration</h3>

<p>Con il service registry stabilizzato, il passo naturale successivo era evolvere verso un <strong>service mesh</strong> – un layer di infrastructure che gestisce service-to-service communication:</p>

<pre><code class="language-python">class ServiceMeshManager:
    &quot;&quot;&quot;
    Advanced service mesh capabilities built on top of service registry
    &quot;&quot;&quot;
    
    def __init__(self, service_registry: ServiceRegistry):
        self.service_registry = service_registry
        self.traffic_manager = TrafficManager()
        self.security_manager = ServiceSecurityManager()
        self.observability_manager = ServiceObservabilityManager()
        
    async def route_request(
        self,
        source_service: str,
        target_capability: str,
        request_payload: Dict[str, Any],
        routing_context: RoutingContext
    ) -&gt; ServiceResponse:
        &quot;&quot;&quot;
        Advanced request routing with traffic management, security, and observability
        &quot;&quot;&quot;
        # 1. Service discovery with intelligent selection
        target_service = await self.service_registry.select_optimal_service(
            target_capability, routing_context
        )
        
        # 2. Apply traffic management policies
        traffic_policy = await self.traffic_manager.get_policy(
            source_service, target_service.service_name
        )
        
        if traffic_policy.should_throttle(routing_context):
            return ServiceResponse.throttled(traffic_policy.throttle_reason)
        
        # 3. Apply security policies
        security_policy = await self.security_manager.get_policy(
            source_service, target_service.service_name
        )
        
        if not await security_policy.authorize_request(request_payload, routing_context):
            return ServiceResponse.unauthorized(&quot;Security policy violation&quot;)
        
        # 4. Add observability headers
        enriched_request = await self.observability_manager.enrich_request(
            request_payload, source_service, target_service.service_name
        )
        
        # 5. Execute request with circuit breaker and retries
        try:
            response = await self._execute_with_resilience(
                target_service, enriched_request, traffic_policy
            )
            
            # 6. Record successful interaction
            await self.observability_manager.record_success(
                source_service, target_service.service_name, response
            )
            
            return response
            
        except Exception as e:
            # 7. Handle failure with observability
            await self.observability_manager.record_failure(
                source_service, target_service.service_name, e
            )
            
            # 8. Apply failure handling policy
            return await self._handle_service_failure(
                source_service, target_service, e, traffic_policy
            )</code></pre>

<h3>Production Results: The Modularization Dividend</h3>

<p>Dopo 3 settimane con la service registry architecture in produzione:</p>

<table>
<thead>
<tr>
<th>Metrica</th>
<th>Monolite</th>
<th>Service Registry</th>
<th>Miglioramento</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Deploy Frequency</strong></td>
<td>1x/week</td>
<td>5x/week per service</td>
<td><strong>+400%</strong></td>
</tr>
<tr>
<td><strong>Mean Time to Recovery</strong></td>
<td>45 minutes</td>
<td>8 minutes</td>
<td><strong>-82%</strong></td>
</tr>
<tr>
<td><strong>Development Velocity</strong></td>
<td>2 features/week</td>
<td>7 features/week</td>
<td><strong>+250%</strong></td>
</tr>
<tr>
<td><strong>System Availability</strong></td>
<td>99.2%</td>
<td>99.8%</td>
<td><strong>+0.6pp</strong></td>
</tr>
<tr>
<td><strong>Resource Utilization</strong></td>
<td>68% average</td>
<td>78% average</td>
<td><strong>+15%</strong></td>
</tr>
<tr>
<td><strong>Onboarding Time (new devs)</strong></td>
<td>2 weeks</td>
<td>3 days</td>
<td><strong>-79%</strong></td>
</tr>
</tbody>
</table>

<h3>The Microservices Paradox: Complexity vs Flexibility</h3>

<p>Il service registry ci aveva dato flexibility enorme, ma aveva anche introdotto nuovi tipi di complessità:</p>

<p><strong>Complessità Added:</strong>
- Network latency tra services
- Service discovery overhead
- Distributed debugging difficulty
- Configuration management complexity
- Monitoring across multiple services</p>

<p><strong>Benefici Gained:</strong>
- Independent deployment cycles
- Technology diversity (different services, different languages)
- Fault isolation (one service down ≠ system down)
- Team autonomy (teams own their services)
- Scalability granularity (scale only what needs scaling)</p>

<p><strong>La Lezione:</strong> Microservices architecture non è "free lunch". È un trade-off consapevole tra operational complexity e development flexibility.</p>

<div class="key-takeaways-section">
    <h4 class="key-takeaways-title">📝 Key Takeaways del Capitolo:</h4>
    <div class="key-takeaways-content"><p class="takeaway-item">✓ <strong>Service Discovery &gt; Hard Dependencies:</strong> Dynamic service discovery eliminates tight coupling and enables independent evolution.</p>
<p class="takeaway-item">✓ <strong>Dependency-Aware Startup is Critical:</strong> Services with dependencies must start in correct order to avoid race conditions.</p>
<p class="takeaway-item">✓ <strong>Health Monitoring Must Be Proactive:</strong> Reactive health checks find problems too late. Predictive monitoring prevents failures.</p>
<p class="takeaway-item">✓ <strong>Intelligent Service Selection &gt; Simple Load Balancing:</strong> Choose services based on performance, load, specialization, and cost.</p>
<p class="takeaway-item">✓ <strong>Service Mesh Evolution is Natural:</strong> Service registry naturally evolves to service mesh with traffic management and security.</p>
<p class="takeaway-item">✓ <strong>Microservices Have Hidden Costs:</strong> Network latency, distributed debugging, and operational complexity are real costs to consider.</p>
    </div>
</div>

<p><strong>Conclusione del Capitolo</strong></p>

<p>La Service Registry Architecture ci ha trasformato da un monolite fragile e difficile da modificare a un ecosistema di servizi flessibili e indipendentemente deployabili. Ma più importante, ci ha dato la <strong>foundation per scalare il team e l'organizzazione</strong>, non solo la tecnologia.</p>

<p>Con servizi che potevano essere sviluppati, deployati e scalati indipendentemente, eravamo pronti per la prossima sfida: <strong>consolidare tutti i sistemi di memoria frammentati</strong> in un'unica, intelligente knowledge base che potesse imparare e migliorare continuamente.</p>

<p>Il <strong>Holistic Memory Consolidation</strong> sarebbe stato il passo finale per trasformare il nostro sistema da "collection of smart services" a "unified intelligent organism".</p>
            </div>

            
        </article>

        <!-- Bottom Navigation -->
        <div class="container">
    <nav class="chapter-nav-bottom">
            <a href="../rate-limiting-circuit-breakers-resilienza/" class="nav-button secondary">← Capitolo Precedente</a>
            <a href="../holistic-memory-consolidation-unificazione/" class="nav-button">Prossimo Capitolo →</a>
        </nav>
    </div>
</div>

                <!-- Reader Tools -->
        <div class="reader-tools" id="readerTools">
            <button class="reader-tools-toggle" onclick="toggleReaderTools()">⚙</button>
            <div class="reader-tool" onclick="toggleTheme()">
                <span class="reader-tool-icon" id="themeIcon">🌙</span>
                <span class="reader-tool-label">Tema</span>
            </div>
            <div class="reader-tool" onclick="toggleBookmark()">
                <span class="reader-tool-icon">🔖</span>
                <span class="reader-tool-label">Bookmark</span>
            </div>
            <div class="reader-tool" onclick="showBookmarks()">
                <span class="reader-tool-icon">📚</span>
                <span class="reader-tool-label">I Miei Bookmark</span>
            </div>
            <div class="reader-tool">
                <span class="reader-tool-icon">🌐</span>
                <select class="language-select" onchange="switchLanguage(this.value)">
                    <option value="it" selected>Italiano</option>
                    <option value="en">English</option>
                </select>
            </div>
            <div class="reader-tool" onclick="showFontSizeMenu()">
                <span class="reader-tool-icon">🔤</span>
                <span class="reader-tool-label">Dimensione Font</span>
            </div>
        </div>
        
        <!-- Reading Progress -->
        <div class="reading-progress">
            <div class="reading-progress-fill" id="progressFill"></div>
        </div>
        
        <!-- Bookmark Toast -->
        <div class="bookmark-toast" id="bookmarkToast">
            <span id="bookmarkMessage">Bookmark salvato!</span>
        </div>

        <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
    <script>
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'base',
            themeVariables: {
                primaryColor: '#667eea',
                primaryTextColor: '#2c3e50',
                primaryBorderColor: '#667eea',
                lineColor: '#7f8c8d',
                secondaryColor: '#f8f9fa',
                tertiaryColor: '#ffffff'
            }
        });
    </script>

    <!-- Prism.js for code highlighting -->
    <link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

    <!-- Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-VEGK4VZMG0"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-VEGK4VZMG0');
        
        gtag('event', 'chapter_start', {
            'chapter_title': 'Service Registry Architecture – Dal Monolite all'Ecosistema',
            'movement': 'memory-system-scaling',
            'chapter_number': 37
        });
    </script>

        
        
        <!-- Reading Progress -->
        <div class="reading-progress">
            <div class="reading-progress-fill" id="progressFill"></div>
        </div>
        
        <!-- Bookmark Toast -->
        <div class="bookmark-toast" id="bookmarkToast">
            <span id="bookmarkMessage">Bookmark salvato!</span>
        
    <!-- Related Chapters Section -->
    <div class="related-chapters-section" id="related-chapters-section">
        <div class="related-chapters-header">
            <h3>🔗 Capitoli Correlati</h3>
            <p>Esplora questi capitoli per approfondire i concetti correlati</p>
        </div>
        <div class="related-chapters-grid">
            
            <div class="related-chapter-item">
                <h4><a href="/it/filosofia-core-architettura/agent-toolbox/" class="related-link">Cassetta degli Attrezzi dell'Agente</a></h4>
                <p>Master AI systems with proven enterprise strategies and <a href="/it/memory-system-scaling/production-readiness-audit-moment-truth/" class="contextual-link" title="strategie di readiness produttiva">production-ready</a> patterns.</p>
                <a href="/it/filosofia-core-architettura/agent-toolbox/" class="related-cta">Approfondisci →</a>
            </div>
        
            <div class="related-chapter-item">
                <h4><a href="/it/filosofia-core-architettura/15-pillars-ai-system/" class="related-link">15 Pilastri del Sistema AI</a></h4>
                <p>Master enterprise architecture with proven enterprise strategies and <a href="/it/memory-system-scaling/production-readiness-audit-moment-truth/" class="contextual-link" title="strategie di readiness produttiva">production-ready</a> patterns.</p>
                <a href="/it/filosofia-core-architettura/15-pillars-ai-system/" class="related-cta">Approfondisci →</a>
            </div>
        
            <div class="related-chapter-item">
                <h4><a href="/it/filosofia-core-architettura/orchestrator-conductor/" class="related-link">Orchestratore come Direttore</a></h4>
                <p>Master production deployment with proven enterprise strategies and <a href="/it/memory-system-scaling/production-readiness-audit-moment-truth/" class="contextual-link" title="strategie di readiness produttiva">production-ready</a> patterns.</p>
                <a href="/it/filosofia-core-architettura/orchestrator-conductor/" class="related-cta">Approfondisci →</a>
            </div>
        
        </div>
    </div>
    
    <style>
    .related-chapters-section {
        margin: 3rem 0;
        padding: 2rem;
        background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
        border-radius: 15px;
        border-left: 5px solid #667eea;
    }
    
    .related-chapters-header {
        text-align: center;
        margin-bottom: 2rem;
    }
    
    .related-chapters-header h3 {
        color: #2c3e50;
        font-size: 1.8rem;
        margin-bottom: 0.5rem;
    }
    
    .related-chapters-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 1.5rem;
    }
    
    .related-chapter-item {
        background: white;
        padding: 1.5rem;
        border-radius: 10px;
        box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        transition: all 0.3s ease;
    }
    
    .related-chapter-item:hover {
        transform: translateY(-5px);
        box-shadow: 0 10px 30px rgba(102, 126, 234, 0.2);
    }
    
    .related-link {
        color: #667eea;
        text-decoration: none;
        font-weight: 600;
    }
    
    .related-link:hover {
        color: #5a6fd8;
        text-decoration: underline;
    }
    
    .related-cta {
        color: #667eea;
        text-decoration: none;
        font-weight: 600;
        font-size: 0.9rem;
        display: inline-flex;
        align-items: center;
        gap: 0.3rem;
        margin-top: 1rem;
    }
    
    .related-cta:hover {
        color: #5a6fd8;
    }
    
    /* Dark mode support */
    .dark-mode .related-chapters-section {
        background: rgba(255, 255, 255, 0.05);
        color: #e9ecef;
    }
    
    .dark-mode .related-chapters-header h3 {
        color: #e9ecef;
    }
    
    .dark-mode .related-chapter-item {
        background: rgba(255, 255, 255, 0.05);
        color: #e9ecef;
    }
    </style>
    
    <!-- Continue Reading Section -->
    <div class="continue-reading-section">
        <div class="continue-reading-header">
            <h3>📚 Continua la Lettura</h3>
        </div>
        <div class="continue-reading-actions">
            <a href="/it/ai-team-orchestrator.html" class="continue-btn primary">
                <span class="btn-icon">🏠</span>
                <span class="btn-text">Torna alla Guida</span>
            </a>
            <a href="/it/filosofia-core-architettura/" class="continue-btn secondary">
                <span class="btn-icon">🎭</span>
                <span class="btn-text">Esplora il Movimento</span>
            </a>
        </div>
    </div>
    
    <style>
    .continue-reading-section {
        margin: 2rem 0;
        padding: 1.5rem;
        text-align: center;
        background: linear-gradient(135deg, #667eea10, #764ba210);
        border-radius: 15px;
    }
    
    .continue-reading-header h3 {
        color: #2c3e50;
        margin-bottom: 1rem;
    }
    
    .continue-reading-actions {
        display: flex;
        gap: 1rem;
        justify-content: center;
        flex-wrap: wrap;
    }
    
    .continue-btn {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.8rem 1.5rem;
        border-radius: 25px;
        text-decoration: none;
        font-weight: 600;
        transition: all 0.3s ease;
    }
    
    .continue-btn.primary {
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
    }
    
    .continue-btn.secondary {
        background: rgba(102, 126, 234, 0.1);
        color: #667eea;
        border: 2px solid #667eea;
    }
    
    .continue-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3);
    }
    
    .dark-mode .continue-reading-header h3 {
        color: #e9ecef;
    }
    </style>
    </div>

    <script>

        // Reader Tools JavaScript
        let readerToolsCollapsed = false;
        
        // Initialize reader tools
        document.addEventListener('DOMContentLoaded', function() {
            initializeReaderTools();
            updateReadingProgress();
            loadUserPreferences();
        });
        
        // Toggle reader tools visibility
        function toggleReaderTools() {
            const tools = document.getElementById('readerTools');
            readerToolsCollapsed = !readerToolsCollapsed;
            
            if (readerToolsCollapsed) {
                tools.classList.add('collapsed');
            } else {
                tools.classList.remove('collapsed');
            }
            
            localStorage.setItem('readerToolsCollapsed', readerToolsCollapsed);
        }
        
        // Theme toggle functionality
        function toggleTheme() {
            const body = document.body;
            const themeIcon = document.getElementById('themeIcon');
            const isDarkMode = body.classList.contains('dark-mode');
            
            if (isDarkMode) {
                body.classList.remove('dark-mode');
                themeIcon.textContent = '🌙';
                localStorage.setItem('theme', 'light');
            } else {
                body.classList.add('dark-mode');
                themeIcon.textContent = '☀️';
                localStorage.setItem('theme', 'dark');
            }
        }
        
        // Bookmark functionality
        function toggleBookmark() {
            const currentPage = window.location.pathname;
            const pageTitle = document.querySelector('.chapter-title').textContent;
            
            let bookmarks = JSON.parse(localStorage.getItem('bookmarks') || '[]');
            const existingIndex = bookmarks.findIndex(b => b.url === currentPage);
            
            if (existingIndex > -1) {
                bookmarks.splice(existingIndex, 1);
                showToast('Bookmark rimosso!', 'error');
            } else {
                bookmarks.push({
                    url: currentPage,
                    title: pageTitle,
                    timestamp: new Date().toISOString()
                });
                showToast('Bookmark salvato!', 'success');
            }
            
            localStorage.setItem('bookmarks', JSON.stringify(bookmarks));
        }
        
        // Language switching
        function switchLanguage(lang) {
            const currentPath = window.location.pathname;
            let newPath;
            
            if (lang === 'en') {
                newPath = currentPath.replace('/it/', '/en/')
                    .replace('filosofia-core-architettura', 'core-philosophy-architecture')
                    .replace('user-experience-trasparenza', 'user-experience-transparency')
                    .replace('esecuzione-qualita', 'execution-quality')
                    .replace('memory-system-scaling', 'memory-system-scaling')
                    .replace('i-15-pilastri-sistema-ai', '15-pillars-ai-system')
                    .replace('primo-agente-specialist-architecture', 'first-specialist-agent-architecture')
                    .replace('isolare-intelligenza-mock-llm', 'ai-mocking-testing-strategy')
                    .replace('dramma-parsing-contratto-ai', 'drama-parsing-ai-contracts')
                    .replace('sdk-vs-api-battle', 'sdk-vs-direct-api-battle')
                    .replace('agente-ambiente-interazioni-fondamentali', 'agent-environment-interactions')
                    .replace('orchestratore-direttore-orchestra', 'orchestrator-conductor')
                    .replace('staffetta-mancata-handoff', 'failed-handoff-delegation')
                    .replace('recruiter-ai-team-dinamico', 'ai-recruiter-dynamic-team')
                    .replace('test-tool-ancorare-realta', 'tool-testing-reality-anchor')
                    .replace('cassetta-attrezzi-agente', 'agent-toolbox');
            } else if (lang === 'it') {
                newPath = currentPath.replace('/en/', '/it/')
                    .replace('core-philosophy-architecture', 'filosofia-core-architettura')
                    .replace('user-experience-transparency', 'user-experience-trasparenza')
                    .replace('execution-quality', 'esecuzione-qualita')
                    .replace('memory-system-scaling', 'memory-system-scaling')
                    .replace('15-pillars-ai-system', 'i-15-pilastri-sistema-ai')
                    .replace('first-specialist-agent-architecture', 'primo-agente-specialist-architecture')
                    .replace('ai-mocking-testing-strategy', 'isolare-intelligenza-mock-llm')
                    .replace('drama-parsing-ai-contracts', 'dramma-parsing-contratto-ai')
                    .replace('sdk-vs-direct-api-battle', 'sdk-vs-api-battle')
                    .replace('agent-environment-interactions', 'agente-ambiente-interazioni-fondamentali')
                    .replace('orchestrator-conductor', 'orchestratore-direttore-orchestra')
                    .replace('failed-handoff-delegation', 'staffetta-mancata-handoff')
                    .replace('ai-recruiter-dynamic-team', 'recruiter-ai-team-dinamico')
                    .replace('tool-testing-reality-anchor', 'test-tool-ancorare-realta')
                    .replace('agent-toolbox', 'cassetta-attrezzi-agente');
            }
            
            if (newPath && newPath !== currentPath) {
                window.location.href = newPath;
            }
        }
        
        // Font size menu (simplified)
        function showFontSizeMenu() {
            const currentSize = localStorage.getItem('fontSize') || 'medium';
            let newSize;
            
            switch (currentSize) {
                case 'small':
                    newSize = 'medium';
                    break;
                case 'medium':
                    newSize = 'large';
                    break;
                case 'large':
                    newSize = 'small';
                    break;
                default:
                    newSize = 'medium';
            }
            
            setFontSize(newSize);
            localStorage.setItem('fontSize', newSize);
            showToast(`Dimensione font: ${newSize}`, 'success');
        }
        
        // Set font size
        function setFontSize(size) {
            const root = document.documentElement;
            const sizes = {
                small: '0.9',
                medium: '1.0',
                large: '1.1'
            };
            root.style.fontSize = sizes[size] + 'em';
        }
        
        // Show toast notification (improved)
        function showToast(message, type = 'success') {
            const toast = document.getElementById('bookmarkToast');
            const messageEl = document.getElementById('bookmarkMessage');
            
            if (!toast || !messageEl) return;
            
            // Clear any existing timeouts
            if (window.toastTimeout) {
                clearTimeout(window.toastTimeout);
            }
            
            // Reset classes and set message
            toast.classList.remove('show', 'error');
            messageEl.textContent = message;
            
            // Add appropriate classes
            if (type === 'error') {
                toast.classList.add('error');
            }
            
            // Show toast
            toast.classList.add('show');
            
            // Hide after delay
            window.toastTimeout = setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }
        
        // Reading progress
        function updateReadingProgress() {
            const progressFill = document.getElementById('progressFill');
            
            window.addEventListener('scroll', () => {
                const article = document.querySelector('.chapter-content');
                if (!article) return;
                
                const articleTop = article.offsetTop;
                const articleHeight = article.offsetHeight;
                const windowHeight = window.innerHeight;
                const scrollTop = window.pageYOffset;
                
                const progress = Math.min(100, Math.max(0, 
                    ((scrollTop + windowHeight - articleTop) / articleHeight) * 100
                ));
                
                progressFill.style.width = progress + '%';
            });
        }
        
        // Load user preferences
        function loadUserPreferences() {
            // Load theme
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme === 'dark') {
                document.body.classList.add('dark-mode');
                document.getElementById('themeIcon').textContent = '☀️';
            }
            
            // Load font size
            const savedFontSize = localStorage.getItem('fontSize');
            if (savedFontSize) {
                setFontSize(savedFontSize);
            }
            
            // Load reader tools state
            const toolsCollapsed = localStorage.getItem('readerToolsCollapsed') === 'true';
            if (toolsCollapsed) {
                document.getElementById('readerTools').classList.add('collapsed');
                readerToolsCollapsed = true;
            }
        }
        
        // Initialize reader tools
        function initializeReaderTools() {
            // Check if current page is bookmarked
            const currentPage = window.location.pathname;
            const bookmarks = JSON.parse(localStorage.getItem('bookmarks') || '[]');
            const isBookmarked = bookmarks.some(b => b.url === currentPage);
            
            if (isBookmarked) {
                document.querySelector('.reader-tool:nth-child(3)').classList.add('active');
            }
        
    
        // Show bookmarks modal
        function showBookmarks() {
            const modal = document.getElementById('bookmarksModal');
            const bookmarksList = document.getElementById('bookmarksList');
            const bookmarks = JSON.parse(localStorage.getItem('bookmarks') || '[]');
            
            if (bookmarks.length === 0) {
                bookmarksList.innerHTML = `
                    <div class="no-bookmarks">
                        <div class="no-bookmarks-icon">📚</div>
                        <h3>Nessun bookmark salvato</h3>
                        <p>Inizia a salvare i tuoi capitoli preferiti cliccando sull'icona 🔖</p>
                    </div>`;
            } else {
                bookmarksList.innerHTML = bookmarks.map(bookmark => `
                    <div class="bookmark-item">
                        <a href="${bookmark.url}" class="bookmark-link">
                            <div class="bookmark-title">${bookmark.title}</div>
                            <div class="bookmark-date">${new Date(bookmark.date).toLocaleDateString('it-IT')}</div>
                        </a>
                        <button class="delete-bookmark" onclick="deleteBookmark('${bookmark.url}')">🗑️</button>
                    </div>
                `).join('');
            }
            
            modal.style.display = 'flex';
            document.body.style.overflow = 'hidden';
        }
        
        function closeBookmarksModal(event) {
            const modal = document.getElementById('bookmarksModal');
            if (modal && (!event || event.target === modal)) {
                modal.style.display = 'none';
                document.body.style.overflow = '';
            }
        }
        
        function deleteBookmark(url) {
            let bookmarks = JSON.parse(localStorage.getItem('bookmarks') || '[]');
            bookmarks = bookmarks.filter(b => b.url !== url);
            localStorage.setItem('bookmarks', JSON.stringify(bookmarks));
            showToast('Bookmark removed!', 'error');
            showBookmarks();
        }
        
        function showToast(message, type = 'success') {
            let toast = document.getElementById('bookmarkToast');
            if (!toast) return;
            
            const messageEl = document.getElementById('bookmarkMessage');
            if (messageEl) messageEl.textContent = message;
            
            toast.style.background = type === 'error' ? '#dc3545' : '#28a745';
            toast.style.opacity = '1';
            toast.style.transform = 'translateY(0)';
            
            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transform = 'translateY(-10px)';
            }, 3000);
        }
        
        document.addEventListener('DOMContentLoaded', function() {
            const currentPage = window.location.pathname;
            const bookmarks = JSON.parse(localStorage.getItem('bookmarks') || '[]');
            const isBookmarked = bookmarks.some(b => b.url === currentPage);
            
            const bookmarkTool = document.querySelector('.reader-tool[onclick*="toggleBookmark"]');
            if (bookmarkTool) {
                bookmarkTool.classList.toggle('active', isBookmarked);
            }
            
            // Load saved theme
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme === 'dark') {
                document.body.classList.add('dark-mode');
                const themeIcon = document.getElementById('themeIcon');
                if (themeIcon) themeIcon.textContent = '☀️';
            }
        });
    
        }
    </script>

<!-- universal-progress-bar-added -->
</body>
</html>